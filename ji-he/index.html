<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>tuyc - 集合</title>
    <meta name="description" content="">
    <meta name="author" content="tuyc">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
    <script src="/theme/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/theme/bootstrap.min.css" rel="stylesheet">
    <link href="/theme/bootstrap.min.responsive.css" rel="stylesheet">
    <link href="/theme/local.css" rel="stylesheet">
    <link href="/theme/pygments.css" rel="stylesheet">

    <!-- So Firefox can bookmark->"abo this site" -->

</head>

<body>

<div class="navbar">
    <div class="navbar-inner">
    <div class="container">

         <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
         </a>

        <a class="brand" href="">tuyc</a>

        <div class="nav-collapse">
        <ul class="nav">
            
        </ul>
        </div>
        
    </div>
    </div>
</div>

<div class="container">
    <div class="content">
    <div class="row">

        <div class="span9">
        

        


    <div class='article'>
        <div class="content-title">
            <a href="/ji-he/my-super-collection.html"><h1>Android 常用数据结构解析</h1></a>
日 06 八月 2017

by <a class="url fn" href="/author/tuyc.html">tuyc</a>
 


 
        </div>
        
        <div><h3>Android 常用数据结构解析</h3>
<p>本着共同学习的原则，来一波常用数据结构源码走读。包括ArrayList、LinkedList、HashMap。对这三种常用到的数据结构进行源码分析，本次列车解析主要包含各数据集合增、删、改、查。</p>
<h4>ArrayList</h4>
<ul>
<li>ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。</li>
</ul>
<p>数据结构：</p>
<p><img alt="" src="https://github.com/tuyc/tuyc.github.io/blob/master/images/WX20170718-171815@2x%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8.png?raw=true" /></p>
<p>线性表的顺序存储结构具有两个基本特点：</p>
<ul>
<li>线性表中所有元素所占的存储空间是连续的；</li>
<li>线性表中各数据元素在存储空间中是按逻辑顺序依次存放的。</li>
</ul>
<h5>源码</h5>
<p>构造函数：</p>
<div class="highlight"><pre><span></span>private static final Object[] EMPTY_ELEMENTDATA = {};
private static final int DEFAULT_CAPACITY = 10;

public ArrayList(int initialCapacity) {
    super();
    if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
    this.elementData = new Object[initialCapacity];
}

public ArrayList() {
    super();
    this.elementData = EMPTY_ELEMENTDATA;
}    
</pre></div>


<p>ArrayList有两个构造函数，一种是给定初始容量，一种是默认构造。使用默认构造函数是不会分配多余的空间的，由源码<code>private static final Object[] EMPTY_ELEMENTDATA = {};</code>可以看出。而对于已分配的空间数量不够情况会怎么办呢？在元素增加（执行add方法）的时候会调用<code>ensureCapacityInternal()</code>方法进行容量检查并扩充容量。下面就来Look下add、remove、set、get方法源码：</p>
<div class="highlight"><pre><span></span>public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

public void add(int index, E element) {
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1, size - index);
        elementData[index] = element;
        size++;
}

public E remove(int index) {
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        modCount++;
        E oldValue = (E) elementData[index];
        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index, numMoved);
        elementData[--size] = null; // clear to let GC do its work
        return oldValue;
}

public E get(int index) {
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        return (E) elementData[index];
 }

 public E set(int index, E element) {
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        E oldValue = (E) elementData[index];
        elementData[index] = element;
        return oldValue;
 }
</pre></div>


<p>ArrayList的数据操作都是简单的数组操作，这里主要介绍下两个方法：<code>ensureCapacityInternal</code>和<code>System.arraycopy</code>。System.arraycopy是数组操作的核心方法，理解了它你就理解了数组世界。</p>
<h6>ensureCapacityInternal</h6>
<div class="highlight"><pre><span></span>public void ensureCapacity(int minCapacity) {
        int minExpand = (elementData != EMPTY_ELEMENTDATA)
            // any size if real element table
            ? 0
            // larger than default for empty table. It&#39;s already supposed to be
            // at default size.
            : DEFAULT_CAPACITY;
        if (minCapacity &gt; minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
}

private void ensureCapacityInternal(int minCapacity) {
   if (elementData == EMPTY_ELEMENTDATA) {
       minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
   }

   ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
  modCount++;

  // overflow-conscious code
   if (minCapacity - elementData.length &gt; 0)
   grow(minCapacity);
}
</pre></div>


<p>你阅读代码后发现，居然都是容量是否足够上的逻辑判断，容量不够的情况最后走到的是<code>grow()</code>方法。</p>
<p>数组容量增长：</p>
<div class="highlight"><pre><span></span>private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
}
</pre></div>


<p>这里主要介绍下<code>Arrays.copyOf</code>方法，跟踪Arrays.copyOf代码可以看到核心还是<code>System.arraycopy</code>方法。</p>
<h6>System.arraycopy：</h6>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * @param      src      源数组</span>
<span class="cm"> * @param      srcPos   源数组复制的起始位置</span>
<span class="cm"> * @param      dest     目的数组</span>
<span class="cm"> * @param      destPos  目的数组放置的起始位置</span>
<span class="cm"> * @param      length   复制的长度</span>
<span class="cm"> */</span><span class="w"></span>
public<span class="w"> </span>static<span class="w"> </span>native<span class="w"> </span>void<span class="w"> </span>arraycopy<span class="o">(</span>Object<span class="w"> </span>src<span class="o">,</span><span class="w">  </span>int<span class="w">  </span>srcPos<span class="o">,</span><span class="w"></span>
<span class="w">                                        </span>Object<span class="w"> </span>dest<span class="o">,</span><span class="w"> </span>int<span class="w"> </span>destPos<span class="o">,</span><span class="w"></span>
<span class="w">                                        </span>int<span class="w"> </span>length<span class="o">)</span><span class="err">;</span><span class="w"></span>
</pre></div>


<p>该方法是native的，不对底层的源码进行研究，知道方法用法和产生的结果就OK了。根据参数的解释很好理解可以达到的效果，有兴趣的朋友可以直接调这个函数进行试验。</p>
<h5>小结</h5>
<p>ArrayList实例都有一个容量，它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝<code>Arrays.copyOf(elementData, newCapacity)</code>，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。 </p>
<h4>LinkedList</h4>
<ul>
<li>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。</li>
<li>LinkedList 实现 List 接口，能对它进行队列操作。</li>
<li>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。</li>
</ul>
<p>数据结构：</p>
<p><img alt="" src="https://github.com/tuyc/tuyc.github.io/blob/master/images/WX20170719-003336@2x.png?raw=true" /></p>
<p>链表存储结构具有两个基本特点：</p>
<ul>
<li>链表是一种物理存储单元上非连续、非顺序的存储结构。</li>
<li>数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</li>
</ul>
<h5>源码</h5>
<p>构造函数：</p>
<div class="highlight"><pre><span></span><span class="kr">public</span> <span class="nx">LinkedList</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kr">public</span> <span class="nx">LinkedList</span><span class="p">(</span><span class="nx">Collection</span><span class="cp">&lt;?</span> <span class="k">extends</span> <span class="nx">E</span><span class="o">&gt;</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">();</span>
   <span class="nx">addAll</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>LinkedList的构造函数有两个：一种是默认构造和一种是给初始集合数据。使用有参构造函数会把Collection数据依次取出放到链表的尾部。这里先来看一下构造函数中使用到的<code>addAll()</code>方法：</p>
<div class="highlight"><pre><span></span><span class="kr">public</span> <span class="kr">boolean</span> <span class="nx">addAll</span><span class="p">(</span><span class="nx">Collection</span><span class="cp">&lt;?</span> <span class="k">extends</span> <span class="nx">E</span><span class="o">&gt;</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">addAll</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="nx">boolean</span> <span class="nx">addAll</span><span class="p">(</span><span class="nx">int</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">Collection</span><span class="o">&lt;?</span> <span class="k">extends</span> <span class="nx">E</span><span class="o">&gt;</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">checkPositionIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>

   <span class="nx">Object</span><span class="p">[]</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">c</span><span class="o">.</span><span class="nx">toArray</span><span class="p">();</span>
   <span class="nx">int</span> <span class="nx">numNew</span> <span class="o">=</span> <span class="nx">a</span><span class="o">.</span><span class="nx">length</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">numNew</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

   <span class="nx">Node</span><span class="o">&lt;</span><span class="nx">E</span><span class="o">&gt;</span> <span class="nx">pred</span><span class="p">,</span> <span class="nx">succ</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">==</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">succ</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="nx">pred</span> <span class="o">=</span> <span class="nx">last</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">succ</span> <span class="o">=</span> <span class="nx">node</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>
            <span class="nx">pred</span> <span class="o">=</span> <span class="nx">succ</span><span class="o">.</span><span class="nb">prev</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="nx">Object</span> <span class="nx">o</span> <span class="o">:</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">@</span><span class="nx">SuppressWarnings</span><span class="p">(</span><span class="s2">&quot;unchecked&quot;</span><span class="p">)</span> <span class="nx">E</span> <span class="nx">e</span> <span class="o">=</span> <span class="p">(</span><span class="nx">E</span><span class="p">)</span> <span class="nx">o</span><span class="p">;</span>
            <span class="nx">Node</span><span class="o">&lt;</span><span class="nx">E</span><span class="o">&gt;</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="nx">pred</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">pred</span> <span class="o">==</span> <span class="k">null</span><span class="p">)</span>
                <span class="nx">first</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="nx">pred</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
            <span class="nx">pred</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
       <span class="p">}</span>
       <span class="k">if</span> <span class="p">(</span><span class="nx">succ</span> <span class="o">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">last</span> <span class="o">=</span> <span class="nx">pred</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">pred</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nx">succ</span><span class="p">;</span>
            <span class="nx">succ</span><span class="o">.</span><span class="nb">prev</span> <span class="o">=</span> <span class="nx">pred</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">size</span> <span class="o">+=</span> <span class="nx">numNew</span><span class="p">;</span>
        <span class="nx">modCount</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>这个方法的功能就是将Collection集合的全部数据拿出来放到index索引开始的链表上，可能是表头、表中、表尾，根据index参数决定。</p>
<p>下面来Look下add、remove、set、get，以及队列和栈常用方法源码：</p>
<div class="highlight"><pre><span></span>public boolean add(E e) {
        linkLast(e);
        return true;
}

void linkLast(E e) {
        final Node&lt;E&gt; l = last;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
} 

public E remove(int index) {
        checkElementIndex(index);
        return unlink(node(index));
}

 public E set(int index, E element) {
        checkElementIndex(index);
        Node&lt;E&gt; x = node(index);
        E oldVal = x.item;
        x.item = element;
        return oldVal;
 }

 public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
 }

 /*******************队列*****************/
 public E poll() {
        final Node&lt;E&gt; f = first;
        return (f == null) ? null : unlinkFirst(f);
  }

  public boolean offer(E e) {
        return add(e);
  }

/****************栈******************/
public void push(E e) {
    addFirst(e);
}

public E pop() {
    return removeFirst();
}
</pre></div>


<p>LinkedList的数据操作都是简单的链表操作，前提是熟悉链表操作，想当初的C语言学习链表时也是经历了懵懂的代价，成熟了就好。</p>
<p>add方法会把元素加到表尾而不是表头；LinkedList可以当做栈和队列使用是因为实现了Deque接口，有队列poll、offer方法和栈push、pop方法，数据结构是基于链表来实现的；</p>
<h5>小结</h5>
<p>相比ArrayList而言，LinkedList数据的增加，删除，不会有增容和数组拷贝，效率更高效。对于查询和修改，LinkedList需要根据指针依次检查，ArrayList是随存随取，ArrayList会更高效。有一点需要注意，很多时候都会谈到性能问题，但是对于数据量小的情况影响真的不大，哪一种数据结构方便就使用哪种就好了，不用去纠结和比较。</p>
<h4>HashMap</h4>
<ul>
<li>HashMap 是一个采用哈希表（数组+链表）实现的键值对集合，继承自 AbstractMap，实现了 Map 接口 。 </li>
<li>两个关键因子：初始容量、加载因子</li>
<li>插入、获取的时间复杂度基本是 O(1)</li>
</ul>
<p>数据结构：</p>
<p><img alt="" src="https://github.com/tuyc/tuyc.github.io/blob/master/images/WX20170719-001915@2x.png?raw=true" /></p>
<h5>源码</h5>
<p>构造函数：</p>
<div class="highlight"><pre><span></span><span class="kr">static</span> <span class="kr">final</span> <span class="kr">int</span> <span class="nx">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> 
<span class="kr">static</span> <span class="kr">final</span> <span class="kr">float</span> <span class="nx">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="mf">0.75f</span><span class="p">;</span>

<span class="kr">public</span> <span class="nx">HashMap</span><span class="p">(</span><span class="kr">int</span> <span class="nx">initialCapacity</span><span class="p">,</span> <span class="kr">float</span> <span class="nx">loadFactor</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">IllegalArgumentException</span><span class="p">(</span><span class="s2">&quot;Illegal initial capacity: &quot;</span> <span class="o">+</span> <span class="nx">initialCapacity</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">initialCapacity</span> <span class="o">&gt;</span> <span class="nx">MAXIMUM_CAPACITY</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">initialCapacity</span> <span class="o">=</span> <span class="nx">MAXIMUM_CAPACITY</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">initialCapacity</span> <span class="o">&lt;</span> <span class="nx">DEFAULT_INITIAL_CAPACITY</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">initialCapacity</span> <span class="o">=</span> <span class="nx">DEFAULT_INITIAL_CAPACITY</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">loadFactor</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">Float</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">loadFactor</span><span class="p">))</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">IllegalArgumentException</span><span class="p">(</span><span class="s2">&quot;Illegal load factor: &quot;</span> <span class="o">+</span> <span class="nx">loadFactor</span><span class="p">);</span>
        <span class="nx">threshold</span> <span class="o">=</span> <span class="nx">initialCapacity</span><span class="p">;</span>
        <span class="nx">init</span><span class="p">();</span>
<span class="p">}</span>

<span class="kr">public</span> <span class="nx">HashMap</span><span class="p">(</span><span class="kr">int</span> <span class="nx">initialCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">(</span><span class="nx">initialCapacity</span><span class="p">,</span> <span class="nx">DEFAULT_LOAD_FACTOR</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">public</span> <span class="nx">HashMap</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">(</span><span class="nx">DEFAULT_INITIAL_CAPACITY</span><span class="p">,</span> <span class="nx">DEFAULT_LOAD_FACTOR</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">public</span> <span class="nx">HashMap</span><span class="p">(</span><span class="nx">Map</span><span class="cp">&lt;?</span> <span class="k">extends</span> <span class="nx">K</span><span class="p">,</span> <span class="o">?</span> <span class="k">extends</span> <span class="nx">V</span><span class="o">&gt;</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">(</span><span class="nx">Math</span><span class="o">.</span><span class="nb">max</span><span class="p">((</span><span class="nx">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">m</span><span class="o">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">/</span> <span class="nx">DEFAULT_LOAD_FACTOR</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="nx">DEFAULT_INITIAL_CAPACITY</span><span class="p">),</span> <span class="nx">DEFAULT_LOAD_FACTOR</span><span class="p">);</span>
        <span class="nx">inflateTable</span><span class="p">(</span><span class="nx">threshold</span><span class="p">);</span>
        <span class="nx">putAllForCreate</span><span class="p">(</span><span class="nx">m</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>HashMap的构造函数有四个，而最终都会执行<code>HashMap(int initialCapacity, float loadFactor)</code>构造函数，无论是默认构造、初始容量构造，还是初始集合构造。主要有2点：</p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY默认初始容量，DEFAULT_LOAD_FACTOR装载因子，这是个经验值。</li>
<li>可以指定初始容量，以及装载因子。一般情况都会使用默认的装载因子。</li>
</ul>
<p>下面来Look下put（新增和修改）、remove、get源码：</p>
<div class="highlight"><pre><span></span>public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    if (key == null)
        return putForNullKey(value);
    int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);
    int i = indexFor(hash, table.length);
    for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    addEntry(hash, key, value, i);
    return null;
}

static int indexFor(int h, int length) {
       return h &amp; (length-1);
}

void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? sun.misc.Hashing.singleWordWangJenkinsHash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }
        createEntry(hash, key, value, bucketIndex);
    }

void createEntry(int hash, K key, V value, int bucketIndex) {
        HashMapEntry&lt;K,V&gt; e = table[bucketIndex];
        table[bucketIndex] = new HashMapEntry&lt;&gt;(hash, key, value, e);
        size++;
}

public V remove(Object key) {
        Entry&lt;K,V&gt; e = removeEntryForKey(key);
        return (e == null ? null : e.getValue());
}

public V get(Object key) {
        if (key == null)
            return getForNullKey();
        Entry&lt;K,V&gt; entry = getEntry(key);
        return null == entry ? null : entry.getValue();
}
</pre></div>


<ul>
<li>put函数</li>
</ul>
<p>```<br />
  if (key == null)
          return putForNullKey(value);   </p>
<p>```</p>
<p>由此可知key可以为空。  </p>
<p>```<br />
  int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);
  int i = indexFor(hash, table.length);</p>
<p>```</p>
<p>hash的的算法不用care，只要理解根据key得到hash值即可；再根据hash值，<code>indexFor(int h, int length)</code>计算桶（数组）的下标；这一步任务就是定位桶的下标。</p>
<p>```
  for (HashMapEntry<K,V> e = table[i]; e != null; e = e.next) {
          Object k;
          if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
              V oldValue = e.value;
              e.value = value;
              e.recordAccess(this);
              return oldValue;
          }
      }</p>
<p>```</p>
<p>这里可以发现for循环初始值HashMapEntry<K,V> e=table[i]（i是上一步计算出的下标），HashMapEntry是一个链表结点，并拥有next结点；滑动链表结点，依次比较，当<code>e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))</code>条件满足就找到了相同的key，进行修改操作，否则就进行增加操作，如下：</p>
<p>```
  addEntry(hash, key, value, i);</p>
<p>```</p>
<p>最后会执行到：</p>
<p>```
  void createEntry(int hash, K key, V value, int bucketIndex) {
          HashMapEntry<K,V> e = table[bucketIndex];
          table[bucketIndex] = new HashMapEntry&lt;&gt;(hash, key, value, e);
          size++;
  }</p>
<p>```</p>
<p>由代码可以发现，新增的元素都是放在对应桶的链表的表头。由此可以得出不发生hash碰撞情况，插入操作的时间复杂度是O(1)的。</p>
<ul>
<li>remove函数</li>
</ul>
<p>```
  final Entry<K,V> removeEntryForKey(Object key) {
          if (size == 0) {
              return null;
          }
          int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key);
          int i = indexFor(hash, table.length);
          HashMapEntry<K,V> prev = table[i];
          HashMapEntry<K,V> e = prev;
          while (e != null) {
              HashMapEntry<K,V> next = e.next;
              Object k;
              if (e.hash == hash &amp;&amp;
                  ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
                  modCount++;
                  size--;
                  if (prev == e)
                      table[i] = next;
                  else
                      prev.next = next;
                  e.recordRemoval(this);
                  return e;
              }
              prev = e;
              e = next;
          }
          return e;
      }</p>
<p>```</p>
<p>可以发现主要的过程也是由key得到hash值，再定位桶的下标，继续遍历链表，寻找与之对应的key，之后都是链表操作就不再描述了。</p>
<ul>
<li>get函数</li>
</ul>
<p>核心函数是：</p>
<p>```</p>
<p>final Entry<K,V> getEntry(Object key) {
          if (size == 0) {
              return null;
          }
          int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key);
          for (HashMapEntry<K,V> e = table[indexFor(hash, table.length)];
               e != null;
               e = e.next) {
              Object k;
              if (e.hash == hash &amp;&amp;
                  ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                  return e;
          }
          return null;
      }
  ```</p>
<p>你会发现主要的过程还是根据key得到hash值，根据hash值定位桶的下标，继续遍历链表，寻找与之对应的key，找到了就返回对应的value。由此可以得出：在不发生hash碰撞的情况下，查找的时间复杂度为O(1)。因为不发生Hash碰撞，所要找的元素就是对应桶里的唯一元素，而桶的下标是根据key的hash值计算直接得到的。</p>
<h5>小结</h5>
<p>数组存储的特点：区间是连续的，占用内存严重，故空间复杂的很大。寻址容易，插入和删除困难。</p>
<p>链表存储特点：区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。寻址困难，插入和删除容易。</p>
<p>哈希表就是结合了两者特性，做出一种寻址容易，插入删除也容易的数据结构。</p></div>
        <hr />
    </div>
		
<div class="pagination">
<ul>
    <li class="prev disabled"><a href="#">&larr; Previous</a></li>

    <li class="active"><a href="/ji-he/index.html">1</a></li>

    <li class="next disabled"><a href="#">&rarr; Next</a></li>

</ul>
</div>
 
  
        </div>
        
        <div class="span3">

            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Site
                </li>
            
                <li><a href="/archives.html">Archives</a>
                <li><a href="/tags.html">Tags</a>




            </ul>
            </div>


            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Categories
                </li>
                
                <li><a href="/android-animation/index.html">Android Animation</a></li>
                <li><a href="/android-material-design/index.html">Android Material Design</a></li>
                <li><a href="/ji-he/index.html">集合</a></li>
                <li><a href="/misc/index.html">misc</a></li>
                <li><a href="/xian-cheng/index.html">线程</a></li>
                   
            </ul>
            </div>
            


            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Links
                </li>
            
                <li><a href="http://getpelican.com/">Pelican</a></li>
                <li><a href="http://python.org/">Python.org</a></li>
                <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
            </ul>
            </div>


            <div class="social">
            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Social
                </li>
           
                <li><a href="https://www.infoq.com/">InfoQ</a></li>
                <li><a href="http://gityuan.com/">Gityuan</a></li>
            </ul>
            </div>
            </div>

        </div>  
    </div>     </div> 
<footer>
<br />
<p><a href="">tuyc</a> &copy; tuyc 2017</p>
</footer>

</div> <!-- /container -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script src="/theme/bootstrap-collapse.js"></script>
 
</body>
</html>